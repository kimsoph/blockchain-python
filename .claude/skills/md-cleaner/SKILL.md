---
name: md-cleaner
description: 마크다운 문법에 충실하게 클리닝 작업을 수행하는 스킬. PDF 변환, OCR, 웹 스크래핑, HWPX 변환 등으로 생성된 마크다운 파일에서 불필요한 줄바꿈, 공백, 페이지번호, 특수문자, 제어문자를 제거하여 깔끔한 마크다운으로 정리한다. v3.3에서 법제처 HWPX 변환 아티팩트(^1. 각주마커, {이미지파일목록} 플레이스홀더) 제거 기능이 추가되었다. 클리닝된 파일은 *_clean.md로 원본 문서와 동일한 폴더에 저장된다. 마크다운 정리, 문서 클리닝, PDF/HWPX 변환 후처리가 필요할 때 사용.
---

# Markdown Cleaner

## 버전 히스토리

### v3.3 (2026-02-04)
- **HWPX 변환 아티팩트 제거**: 법제처 국가법령정보센터 HWPX 파일 변환 시 발생하는 아티팩트 자동 제거
  - `^1.`, `^2.`, `^3)` 등 각주/미주 마커 제거
  - `{이미지파일목록}`, `{국가법령이미지로고목록}` 등 플레이스홀더 제거
- **is_hwpx_artifact_line() 메서드 추가**: HWPX 아티팩트 라인 감지 로직 분리

### v3.2 (2026-01-30)
- **대문자 로마숫자 인식**: I., II., III., IV., V. 등 대문자 로마숫자 헤더의 줄바꿈 보존
- **OCR 아티팩트 정리**: 일본어 히라가나 'へ'(U+3078)를 화살표 '→'로 자동 교정 (PDF 변환 시 오인식 문제 해결)

### v3.1 (2026-01-06)
- **로깅 시스템**: logging 모듈 도입, `--quiet`/`--verbose` 옵션 추가
- **페이지번호 범위 옵션**: `--page-max N`으로 페이지 번호 감지 범위 조정 가능 (기본: 100)
- **HTML 엔티티 처리**: `&nbsp;`, `&lt;`, `&gt;`, `&amp;` 등 자동 디코딩
- **링크/이미지 보호**: `[text](url)`, `![alt](url)` 내부 텍스트 완벽 보존
- **테이블 정렬**: `--align-tables` 옵션으로 마크다운 테이블 열 너비 정렬
- **커스텀 패턴**: `--extra-pattern`으로 추가 제거 패턴 지정 가능
- **requirements.txt 추가**: chardet 의존성 명시
- **단위 테스트 확장**: 42개 → 64개 (+22개)

### v3.0 (2025-12-18)
- **인라인 코드 보호**: 백틱(`) 내부 텍스트 완벽 보존
- **코드 블록 불일치 경고**: 닫히지 않은 코드 블록 감지 및 경고
- **정규식 사전 컴파일**: 성능 최적화 (대용량 파일 처리 속도 향상)
- **--dry-run 옵션**: 실제 파일 수정 없이 결과 미리보기
- **--diff 옵션**: 원본과 클리닝 결과의 차이 출력
- **--backup 옵션**: 기존 파일 자동 백업 (.md.bak)
- **배치 처리**: 디렉토리 내 모든 .md 파일 일괄 처리 (`--batch`, `-r`)
- **코드 블록 감지 로직 통합**: 중복 코드 제거, 안정성 향상
- **문장 줄바꿈 삭제 강화**: 한국어 종결어미 패턴 확장 (니다, 습니다, 세요 등)
- **페이지번호 패턴 확장**: p.1, pp.1-2, 1쪽, 제1쪽, (1/10) 형식 추가
- **단위 테스트 추가**: 42개 테스트 케이스로 품질 보증

### v2.0 (2025-12-05)
- **페이지번호 삭제 강화**: en-dash(–), em-dash(—) 포함 다양한 형식 지원
- **마크다운 문법 오류 수정**: `- *`, `- -`, `- **` 등 잘못된 리스트 문법 자동 수정
- **불필요한 텍스트 강조 제거**: 전체 문서에 과도하게 적용된 볼드, 이탤릭, 밑줄 제거
- **문장 줄바꿈 병합**: 문장 중간에서 끊어진 줄바꿈을 자동으로 병합 (한국어 종결어미 인식)

### v1.0 (2025-11-04)
- 초기 버전: 기본 클리닝 기능 (페이지 번호, 공백, 제어문자 제거)

## 개요

이 스킬은 마크다운 파일을 클리닝하여 불필요한 요소를 제거하고 마크다운 문법에 충실한 형태로 정리한다. PDF 변환, OCR, 웹 스크래핑 등으로 생성된 마크다운 파일은 페이지 번호, 과도한 공백, 제어 문자, 잘못된 문법 등 불필요한 요소가 많이 포함된다. 이 스킬은 이러한 요소를 자동으로 제거하면서도 유효한 마크다운 문법은 완벽히 보존한다.

v3.0에서는 안정성과 사용성이 대폭 강화되었다:
- 인라인 코드(`code`)와 코드 블록(```)을 완벽히 보호
- 배치 처리로 여러 파일을 한 번에 클리닝
- --dry-run으로 변경사항 미리 확인 가능
- 42개 단위 테스트로 품질 보증

## 사용 시점

다음과 같은 상황에서 이 스킬을 사용한다:

- PDF를 마크다운으로 변환한 후 정리가 필요할 때
- OCR 결과물을 마크다운으로 변환하여 정리할 때
- 웹 스크래핑으로 얻은 마크다운 콘텐츠를 정리할 때
- markitdown, pdf-reader 등 변환 도구 사용 후 후처리가 필요할 때
- 법제처 HWPX 파일을 마크다운으로 변환한 후 정리할 때 (v3.3)
- 불필요한 공백, 줄바꿈, 페이지 번호가 많은 마크다운 파일이 있을 때
- 한글 인코딩 문제가 있는 마크다운 파일을 UTF-8로 정리할 때
- 여러 마크다운 파일을 한 번에 정리할 때 (v3.0 배치 처리)

## 작업 흐름

### Step 1: 파일 클리닝 실행

유저로부터 클리닝할 마크다운 파일 경로를 입력받으면, 다음을 수행한다:

1. **스크립트 실행**: `scripts >> clean_markdown.py`를 사용하여 파일 클리닝을 수행한다.

```bash
# 기본 사용법
python scripts/clean_markdown.py <입력파일> [출력파일]

# v3.0 새 옵션들
python scripts/clean_markdown.py --dry-run <입력파일>     # 미리보기
python scripts/clean_markdown.py --diff <입력파일>        # 차이 확인
python scripts/clean_markdown.py --backup <입력파일>      # 백업 생성
python scripts/clean_markdown.py --batch <디렉토리>       # 배치 처리
python scripts/clean_markdown.py --batch -r <디렉토리>    # 재귀적 배치 처리
```

2. **기본 동작**:
   - 입력 파일을 UTF-8로 읽기 (실패 시 자동 인코딩 감지)
   - 클리닝 규칙 적용
   - `*_clean.md` 파일로 저장 (원본과 동일한 폴더)

3. **출력 경로 지정** (선택사항):
   - 출력 파일명을 지정하지 않으면 자동으로 `입력파일명_clean.md`로 저장
   - 출력 경로를 지정하면 해당 경로에 저장

### Step 2: 클리닝 규칙 적용

클리닝은 다음 순서로 진행된다:

1. **코드 블록 불일치 체크** (v3.0 신규)
   - 닫히지 않은 코드 블록 감지 및 경고 출력

2. **코드 블록 추출** (v3.0 신규)
   - 코드 블록(```)을 플레이스홀더로 대체하여 보호

3. **인라인 코드 추출** (v3.0 신규)
   - 인라인 코드(`)를 플레이스홀더로 대체하여 보호

4. **제어 문자 제거**
   - 화면에 표시되지 않는 제어 문자 제거
   - 줄바꿈, 탭은 보존

5. **유니코드 정규화**
   - Zero-width 문자 제거 (U+200B, U+FEFF 등)
   - 비표준 공백을 일반 스페이스로 변환 (U+00A0, U+3000 등)

6. **페이지 번호 제거** (v3.0 강화)
   - "페이지 1", "Page 1", "[1]", "- 1 -" 등 제거
   - en-dash(–), em-dash(—) 형식도 지원
   - v3.0 추가: "p. 1", "pp. 1-2", "1쪽", "제1쪽", "(1/10)" 형식
   - 100 이하 단독 숫자 제거 (페이지 번호로 추정)
   - 마크다운 문법 요소(헤더, 리스트)가 있는 라인은 보존

7. **마크다운 문법 오류 수정**
   - `- *`, `- -`, `- **` 등 잘못된 리스트 문법을 `- `로 수정
   - `- ※`, `- ○`, `- □` 등 특수문자로 시작하는 리스트 정리
   - 빈 리스트 항목 제거

8. **텍스트 강조 제거**
   - 과도한 볼드(`**text**`) 제거
   - 과도한 이탤릭(`*text*`, `_text_`) 제거
   - 취소선(`~~text~~`) 제거
   - 하이라이트(`==text==`) 제거
   - 코드 블록/인라인 코드 내부는 보존

9. **문장 줄바꿈 병합** (v3.0 강화)
   - 문장 중간에서 끊어진 줄을 자동으로 병합
   - 한국어 종결어미 확장: 니다, 습니다, 세요, 시오, 네요, 군요, 지요 등
   - 마크다운 문법 요소(헤딩, 리스트, 인용구, 코드 등)는 보존

10. **공백 정리**
    - 연속 공백을 하나로 축소 (코드 블록 제외)
    - 줄 끝 공백 제거 (마크다운 줄바꿈용 정확히 2개 스페이스만 보존)

11. **빈 줄 정리**
    - 3개 이상 연속 빈 줄을 2개로 축소
    - 문서 시작/끝의 불필요한 빈 줄 제거

12. **코드 복원** (v3.0 신규)
    - 인라인 코드 복원
    - 코드 블록 복원

13. **파일 저장**
    - UTF-8 인코딩으로 저장
    - 원본 파일은 그대로 유지

### Step 3: 결과 확인 및 검토

클리닝 완료 후 다음을 확인한다:

1. **출력 메시지 확인**:
   ```
   [OK] 클리닝 완료: /path/to/file_clean.md
     원본 크기: 1,234 bytes
     클리닝 후: 987 bytes
     감소: 247 bytes (20.0%)
   ```

2. **파일 검토**:
   - 중요한 숫자가 페이지 번호로 오인되어 제거되지 않았는지 확인
   - 코드 블록의 들여쓰기가 보존되었는지 확인
   - 마크다운 문법이 정상적으로 보존되었는지 확인

3. **문제 발생 시**:
   - 원본 파일은 그대로 유지되므로 `*_clean.md` 파일을 삭제하고 재시도
   - 특정 패턴이 잘못 제거되면 스크립트 수정 고려

## 명령줄 옵션 (v3.1)

| 옵션 | 단축 | 기본값 | 설명 |
|------|------|--------|------|
| `--dry-run` | `-n` | False | 실제 파일 수정 없이 결과만 미리보기 |
| `--diff` | `-d` | False | 원본과 클리닝 결과의 차이 출력 |
| `--backup` | `-b` | False | 기존 파일 백업 (.md.bak) |
| `--batch` | | False | 디렉토리 내 모든 .md 파일 일괄 처리 |
| `-r`, `--recursive` | | False | 하위 디렉토리까지 재귀적으로 처리 (--batch와 함께) |
| `--version` | `-v` | | 버전 정보 출력 |
| `--quiet` | `-q` | False | 경고만 출력 (정보 메시지 숨김) **(v3.1)** |
| `--verbose` | | False | 상세 로그 출력 (디버그 정보 포함) **(v3.1)** |
| `--page-max` | | 100 | 페이지 번호로 간주할 최대 숫자 **(v3.1)** |
| `--align-tables` | | False | 마크다운 테이블 열 너비 정렬 **(v3.1)** |
| `--extra-pattern` | | [] | 추가 제거 패턴 (정규식, 여러 번 사용 가능) **(v3.1)** |

## 클리닝 규칙 상세

### HTML 엔티티 처리 (v3.1 신규)

PDF/OCR 변환 시 남아있는 HTML 엔티티를 자동으로 디코딩한다:

| HTML 엔티티 | 변환 결과 | 설명 |
|-------------|-----------|------|
| `&nbsp;` | (공백) | Non-breaking space → 일반 공백으로 변환 |
| `&lt;` | `<` | Less than |
| `&gt;` | `>` | Greater than |
| `&amp;` | `&` | Ampersand |
| `&quot;` | `"` | Double quote |
| `&#60;` | `<` | 숫자 엔티티도 지원 |

**처리 순서**: HTML 엔티티 디코딩 후 `&nbsp;`로 생성된 non-breaking space는 `remove_unusual_unicode` 단계에서 일반 스페이스로 정규화됨.

### 마크다운 링크/이미지 보호 (v3.1 신규)

마크다운 링크와 이미지의 내부 텍스트를 완벽하게 보존한다:

```markdown
# 보존되는 경우

[**볼드 링크**](https://example.com) → 그대로 유지
![이미지  공백](path/to/image.png) → 그대로 유지

# 외부 텍스트는 클리닝됨
텍스트 **볼드** [링크](url) → 텍스트 볼드 [링크](url)
```

**동작 원리**:
1. 코드 블록/인라인 코드 추출 후 링크/이미지 추출
2. 플레이스홀더로 치환하여 클리닝에서 제외
3. 클리닝 완료 후 원래대로 복원

### 테이블 정렬 (v3.1 신규)

`--align-tables` 옵션으로 마크다운 테이블의 열 너비를 정렬할 수 있다:

**입력:**
```markdown
| 이름 | 설명 |
|---|---|
| A | 짧은 텍스트 |
| B | 매우 긴 텍스트입니다 |
```

**출력 (--align-tables):**
```markdown
| 이름 | 설명                 |
|------|----------------------|
| A    | 짧은 텍스트          |
| B    | 매우 긴 텍스트입니다 |
```

**한글 너비 계산**: 한글, 한자, 일본어 등 동아시아 문자는 2칸으로 계산하여 정렬.

### 커스텀 패턴 (v3.1 신규)

`--extra-pattern`으로 추가 제거 패턴을 지정할 수 있다:

```bash
# 특정 텍스트 제거
python clean_markdown.py --extra-pattern "^\s*\[제거\]\s*$" doc.md

# 여러 패턴 지정
python clean_markdown.py \
  --extra-pattern "^\s*\[END\]\s*$" \
  --extra-pattern "^\s*\[START\]\s*$" \
  doc.md
```

**주의**: 정규식 문법을 사용. 줄 전체가 패턴과 일치해야 제거됨.

### 페이지 번호 제거 (v3.1 강화)

다음 패턴의 페이지 번호를 제거한다:

| 패턴 | 예시 |
|------|------|
| 한글 페이지 | "페이지 1", "페이지 25" |
| 영문 페이지 | "Page 1", "Page 42" |
| 영문 축약 (v3.0) | "p. 1", "pp. 1-2" |
| 한글 쪽 (v3.0) | "1쪽", "제1쪽" |
| 슬래시 구분 | "1 / 10", "5/20" |
| 괄호 슬래시 (v3.0) | "(1/10)", "(5/20)" |
| 대괄호 | "[1]", "[25]" |
| 소괄호 (v3.0) | "(1)", "(25)" |
| 하이픈 구분 | "- 1 -", "- 15 -" |
| en-dash 구분 | "– 1 –", "– 15 –" |
| em-dash 구분 | "— 1 —", "— 15 —" |
| 단독 숫자 | "1", "42" (100 이하만) |

**보존되는 경우**:
- 마크다운 헤더: `# 1. 소개`
- 순서 리스트: `1. 첫 번째 항목`
- 100 초과 숫자: `2024`, `500`

### HWPX 변환 아티팩트 제거 (v3.3 신규)

법제처 국가법령정보센터 HWPX 파일 변환 시 발생하는 아티팩트를 자동으로 제거한다:

| 패턴 | 예시 | 설명 |
|------|------|------|
| 각주/미주 마커 | `^1.`, `^2.`, `^3)` | 마크다운 변환 시 남는 각주 참조 |
| 플레이스홀더 | `{이미지파일목록}`, `{국가법령이미지로고목록}` | 이미지/로고 플레이스홀더 |

**처리 방식**:
- `is_hwpx_artifact_line()` 메서드로 아티팩트 라인 감지
- 해당 라인 전체 제거 (내용 변환 없이)

**주의사항**:
- `^` 문자로 시작하는 일반 텍스트는 제거되지 않음 (숫자+마침표/괄호 패턴만 제거)
- 중괄호 `{}` 안에 한글/영문이 있는 플레이스홀더만 제거

### 인라인 코드 및 코드 블록 보호 (v3.0 신규)

v3.0에서 인라인 코드와 코드 블록이 완벽히 보호된다:

```markdown
# 보호되는 경우

`**볼드 코드**`는 그대로 유지됨

```python
**볼드**  연속공백  모두 보존
```

위 코드 블록 내부는 모든 클리닝 규칙에서 제외됨
```

### 마크다운 문법 오류 수정

다음 패턴의 잘못된 리스트 문법을 수정한다:

| 원본 패턴 | 수정 결과 | 설명 |
|-----------|-----------|------|
| `- ** 텍스트` | `- 텍스트` | 볼드 마커가 앞에 붙은 경우 |
| `- * 텍스트` | `- 텍스트` | 이탤릭 마커가 앞에 붙은 경우 |
| `- - 텍스트` | `- 텍스트` | 중복 하이픈 |
| `- ※ 텍스트` | `- 텍스트` | 특수 기호가 앞에 붙은 경우 |
| `- ○ 텍스트` | `- 텍스트` | 원형 기호 |
| `- □ 텍스트` | `- 텍스트` | 사각형 기호 |
| `- ◆ 텍스트` | `- 텍스트` | 다이아몬드 기호 |
| `- ▶ 텍스트` | `- 텍스트` | 화살표 기호 |

### 텍스트 강조 제거

문서 전체에 과도하게 적용된 텍스트 강조를 제거한다:

| 강조 유형 | 원본 | 결과 |
|-----------|------|------|
| 볼드 | `**텍스트**` | `텍스트` |
| 이탤릭 | `*텍스트*` 또는 `_텍스트_` | `텍스트` |
| 취소선 | `~~텍스트~~` | `텍스트` |
| 하이라이트 | `==텍스트==` | `텍스트` |

**보존되는 경우**:
- 코드 블록 내부
- 인라인 코드 내부

### 문장 줄바꿈 병합 (v3.0 강화)

문장 중간에서 끊어진 줄을 자동으로 병합한다. 한국어 문서에 특화되어 있다.

**병합 대상**:
- 문장이 종결어미 없이 끝난 경우
- 다음 줄이 소문자, 한글, 조사로 시작하는 경우

**한국어 종결어미 인식** (v3.0 확장):
- 서술형: 다, 요, 음, 함, 임, 됨
- 명사형: 것, 수, 바, 점
- 존칭형 (v3.0): 니다, 습니다, 세요, 시오
- 설명형 (v3.0): 랍니다, 답니다
- 감탄형 (v3.0): 네요, 군요
- 확인형 (v3.0): 지요, 죠
- 이유/강조형 (v3.0): 거든요, 잖아요

**병합하지 않는 경우**:
- 마크다운 헤딩 (`#`, `##` 등)
- 리스트 항목 (`-`, `*`, `1.` 등)
- 인용구 (`>`)
- 코드 블록 (` ``` `)
- 테이블 행 (`|`)
- 빈 줄
- 수평선 (`---`)
- 원형 숫자 (`①`, `②` 등)
- 한글 순서 (`가.`, `(가)` 등)
- 대문자 로마숫자 (`I.`, `II.`, `III.` 등) **(v3.2)**

### 마크다운 문법 보존

다음 마크다운 문법 요소는 절대 손상되지 않는다:

- **헤더**: `# 제목`, `## 소제목`
- **리스트**: `- 항목`, `1. 순서 항목`
- **인용구**: `> 인용문`
- **코드 블록**: ` ```python ` ... ` ``` `
- **인라인 코드**: `` `code` ``
- **테이블**: `| 열1 | 열2 |`
- **링크**: `[텍스트](URL)`
- **이미지**: `![alt](image.png)`
- **수평선**: `---`

## 사용 예시

### 예시 1: 기본 사용 (자동 출력 파일명)

```bash
python scripts/clean_markdown.py document.md
```

결과: `document_clean.md` 생성

### 예시 2: 출력 파일명 지정

```bash
python scripts/clean_markdown.py input.md output.md
```

결과: `output.md` 생성

### 예시 3: 미리보기 (v3.0)

```bash
python scripts/clean_markdown.py --dry-run document.md
```

결과: 파일 수정 없이 결과만 출력

### 예시 4: 변경사항 확인 (v3.0)

```bash
python scripts/clean_markdown.py --diff document.md
```

결과: unified diff 형식으로 변경사항 출력

### 예시 5: 배치 처리 (v3.0)

```bash
# 현재 디렉토리의 모든 .md 파일 처리
python scripts/clean_markdown.py --batch ./docs/

# 하위 디렉토리까지 재귀적으로 처리
python scripts/clean_markdown.py --batch -r ./docs/
```

결과:
```
==================================================
배치 처리 완료: 15개 파일
==================================================
[OK] ./docs/readme.md
    15,234 → 12,456 bytes (-2,778)
[OK] ./docs/guide.md
    8,901 → 7,234 bytes (-1,667)
...

총 원본: 150,000 bytes
총 클리닝 후: 125,000 bytes
총 감소: 25,000 bytes (16.7%)
```

### 예시 6: Claude Code에서 사용

```
유저: 이 PDF를 마크다운으로 변환한 파일을 정리해주세요: report.md

Claude: md-cleaner 스킬을 사용하여 파일을 클리닝하겠습니다.

[Bash 실행: python scripts/clean_markdown.py report.md]

[OK] 클리닝 완료: report_clean.md
  원본 크기: 15,234 bytes
  클리닝 후: 12,456 bytes
  감소: 2,778 bytes (18.2%)

페이지 번호와 불필요한 공백이 제거되었으며, 마크다운 문법은 모두 보존되었습니다.
```

## 실제 변환 예시

### PDF 변환 마크다운 클리닝

**변환 전 (PDF → Markdown):**
```markdown
# 보고서 제목

페이지 1

## 개요

이    문서는    보고서   입니다.



- 2 -

## 내용

자세한   내용...


페이지 3
```

**클리닝 후:**
```markdown
# 보고서 제목

## 개요

이 문서는 보고서 입니다.

## 내용

자세한 내용...
```

### 인라인 코드 보호 (v3.0)

**변환 전:**
```markdown
`**변수명**`은 중요합니다.

일반 **볼드**도 있습니다.
```

**클리닝 후:**
```markdown
`**변수명**`은 중요합니다.

일반 볼드도 있습니다.
```

인라인 코드 내부의 `**`는 보존되고, 일반 텍스트의 볼드는 제거됨.

### 코드 블록 보호 (v3.0)

**변환 전:**
````markdown
```python
**볼드**  연속공백  보존
```

일반 **볼드**  연속공백  제거
````

**클리닝 후:**
````markdown
```python
**볼드**  연속공백  보존
```

일반 볼드 연속공백 제거
````

코드 블록 내부는 완전히 보존되고, 외부만 클리닝됨.

## 참고 자료

이 스킬은 다음 참고 자료를 포함한다:

### scripts >> clean_markdown.py
마크다운 클리닝을 수행하는 Python 스크립트 v3.0. 다음 기능을 포함한다:
- `CleaningResult` 데이터 클래스: 클리닝 결과 저장
- `CodeBlockExtractor` 클래스: 코드 블록/인라인 코드 추출 및 복원
- `MarkdownCleaner` 클래스: 클리닝 로직 구현
- `process_file()` 메서드: 단일 파일 처리
- `process_directory()` 메서드: 배치 처리
- `generate_diff()` 함수: diff 생성
- argparse 기반 CLI

### tests >> test_clean_markdown.py (v3.0 신규)
42개의 단위 테스트 케이스:
- `TestCodeBlockExtractor`: 코드 블록 추출/복원 테스트
- `TestMarkdownCleaner`: 클리닝 기능 테스트
- `TestShouldJoinLines`: 문장 병합 로직 테스트

### references >> cleaning_rules.md
마크다운 클리닝 시 적용되는 상세 규칙 및 패턴.

## 주의사항

1. **한글 인코딩**:
   - 입력 파일은 UTF-8이 권장되지만, 다른 인코딩도 자동 감지하여 처리
   - 출력 파일은 항상 UTF-8로 저장
   - 한글이 깨지는 경우 원본 인코딩을 확인하고 변환 권장

2. **경로 표시**:
   - 문서 내에서 디렉토리 경로를 언급할 때는 '/' 또는 '\' 대신 '>>'를 사용
   - 예: `scripts >> clean_markdown.py`, `references >> cleaning_rules.md`

3. **원본 보존**:
   - 클리닝된 파일은 `*_clean.md`로 저장되므로 원본은 항상 보존됨
   - `--backup` 옵션으로 추가 백업 생성 가능

4. **검토 필수**:
   - 클리닝 후 결과를 반드시 검토 (특히 중요 문서)
   - 100 이하 단독 숫자는 페이지 번호로 간주되어 제거될 수 있음
   - `--dry-run`으로 미리 확인 권장

5. **코드 블록 확인**:
   - 코드 블록이 ` ``` `로 올바르게 감싸져 있는지 확인
   - v3.0에서 닫히지 않은 코드 블록 경고 제공

6. **대량 처리**:
   - `--batch` 옵션으로 여러 파일 한 번에 처리
   - `-r` 옵션으로 하위 디렉토리까지 재귀 처리
   - `*_clean.md` 파일은 자동으로 건너뜀

## 고급 사용법

### 스크립트 커스터마이징

특정 페이지 번호 패턴을 추가하려면 `clean_markdown.py`의 `page_patterns` 수정:

```python
self.page_patterns = [
    re.compile(r'^\s*페이지\s*\d+\s*$', re.IGNORECASE),
    re.compile(r'^\s*Page\s*\d+\s*$', re.IGNORECASE),
    # 여기에 새 패턴 추가
    re.compile(r'^\s*p\.\s*\d+\s*$', re.IGNORECASE),  # "p. 1" 형식
]
```

### 배치 처리 스크립트 예시

```bash
#!/bin/bash
# 모든 디렉토리의 .md 파일을 재귀적으로 클리닝
python scripts/clean_markdown.py --batch -r ./

# 미리보기 모드로 확인
python scripts/clean_markdown.py --batch -r --dry-run ./

# 백업 포함 클리닝
python scripts/clean_markdown.py --batch -r --backup ./
```

### 단위 테스트 실행

```bash
cd .claude/skills/md-cleaner
python -m pytest tests/test_clean_markdown.py -v
```

## 문제 해결

### 인코딩 오류

**증상**: "UnicodeDecodeError" 발생

**해결**:
- chardet 패키지 설치: `pip install chardet`
- 또는 원본 파일을 UTF-8로 먼저 변환

### 중요 숫자 제거

**증상**: 100 이하 단독 숫자가 페이지 번호로 오인되어 제거됨

**해결**:
- `*_clean.md` 파일에서 수동으로 복원
- 또는 스크립트의 페이지 번호 감지 로직 수정 (숫자 범위 조정)

### 코드 블록 손상

**증상**: 코드 블록 내부 공백이 정리됨

**해결**:
- 원본 파일의 코드 블록이 ` ``` `로 올바르게 감싸져 있는지 확인
- 열린 코드 블록이 닫히지 않았는지 확인 (v3.0에서 경고 제공)

### 닫히지 않은 코드 블록 (v3.0)

**증상**: "경고: N번 줄에서 시작된 코드 블록이 닫히지 않았습니다." 메시지

**해결**:
- 해당 줄에서 시작된 코드 블록에 닫는 ` ``` ` 추가
- 원본 파일 수정 후 재실행

## 출력 형식

클리닝 후 터미널에 다음 정보가 출력된다:

```
[OK] 클리닝 완료: /path/to/file_clean.md
  원본 크기: 15,234 bytes
  클리닝 후: 12,456 bytes
  감소: 2,778 bytes (18.2%)
```

인코딩이 자동 감지된 경우:

```
[OK] 클리닝 완료: /path/to/file_clean.md
  원본 크기: 15,234 bytes
  클리닝 후: 12,456 bytes
  감소: 2,778 bytes (18.2%)
  경고: cp949 인코딩으로 읽었습니다. UTF-8로 저장됩니다.
```

코드 블록 불일치 감지 시 (v3.0):

```
[OK] 클리닝 완료: /path/to/file_clean.md
  원본 크기: 15,234 bytes
  클리닝 후: 12,456 bytes
  감소: 2,778 bytes (18.2%)
  경고: 15번 줄에서 시작된 코드 블록이 닫히지 않았습니다.
```

## 워크플로우 통합

이 스킬은 다른 스킬과 함께 사용할 때 더욱 유용하다:

1. **PDF 변환 → 클리닝**:
   ```
   1. pdf-reader 또는 markitdown으로 PDF → Markdown 변환
   2. md-cleaner로 클리닝
   ```

2. **OCR → 클리닝**:
   ```
   1. pdf-reader의 OCR 기능으로 스캔 PDF → Markdown
   2. md-cleaner로 불필요한 요소 제거
   ```

3. **웹 스크래핑 → 클리닝**:
   ```
   1. 웹 콘텐츠를 Markdown으로 변환
   2. md-cleaner로 정리
   ```

4. **배치 문서 처리 (v3.0)**:
   ```
   1. 여러 PDF를 markitdown으로 변환
   2. md-cleaner --batch -r로 일괄 클리닝
   ```

이러한 워크플로우를 통해 깔끔하고 읽기 쉬운 마크다운 문서를 얻을 수 있다.
